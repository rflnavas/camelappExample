package com.rnrcompany.cameltutorial.components;

import static com.rnrcompany.cameltutorial.util.Constants.EMP_SAL_QUEUE;
import com.fasterxml.jackson.core.JsonParseException;
import com.rnrcompany.cameltutorial.beans.EmployeeSalary;
import com.rnrcompany.cameltutorial.beans.InboundRestProcessingBean;
import org.apache.camel.Exchange;
import org.apache.camel.LoggingLevel;
import org.apache.camel.Predicate;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.model.rest.RestBindingMode;
import org.springframework.stereotype.Component;
import java.net.ConnectException;
import javax.jms.JMSException;

@Component
public class EmployeeRestRouteQueueMultipoint extends RouteBuilder {

    @Override
    public void configure() throws Exception {

        //Possible exceptions that might arise

        //JMS failure due to, i.e, ActiveMQ went down
        //noinspection unchecked
        onException(JMSException.class, ConnectException.class)
            .routeId("jmsExceptionRouteId")
            .handled(true)
            .log(LoggingLevel.INFO, "JMS exception has occurred; handling gracefully");

        //Parsing erroneous JSON during a rest call
        onException(JsonParseException.class)
            .handled(true)
            .setHeader(Exchange.HTTP_RESPONSE_CODE, constant(400))
            .setHeader(Exchange.CONTENT_TYPE, constant("text/plain"))
            .setBody().constant("Invalid json data");

        restConfiguration()
            .component("jetty")
            .host("0.0.0.0")
            .port(9080)
            .bindingMode(RestBindingMode.json)
            .enableCORS(true);

        rest("rnrcompany")
            .produces("application/json")
            .post("employee")
            .type(EmployeeSalary.class)
            .route()
            .routeId("restEmployeeId")
            .log(LoggingLevel.INFO, "${body}")
            .bean(new InboundRestProcessingBean(), "newValidation")
            //Delivering exchange to another point aside from activeMQ. By copying the exchange and not waiting for
            //one exchange to complete before the other one is.

            // with this approach, since these exchanges are parallel executed we will again find out
            // that id=null
            //>>>>Message received from Queue : EmployeeSalary(id=null, department=MBL3, departmentName=....
            //.multicast()
            //    .to("jpa:" + EmployeeSalary.class.getName())
            //    .to(String.format("activemq:queue:%s%s", EMP_SAL_QUEUE, "?exchangePattern=InOnly"));

            /* https://camel.apache.org/components/3.18.x/eips/wireTap-eip.html */

            /*
                Due to seda asynchronous exchange and wiretap makes a copy of the exchange,
                the message that will receive activeMQ will not contain the new stored entity.
             */
            //.wireTap("seda:toDB")
            .choice()
            //We can define choice either this way: simple("${headers.grade} == 'M2'")
            //or with a defined predicate
            .when(header("grade").isEqualTo("M2"))
                .to("seda:toActiveMQ")
            .otherwise()
                .to("direct:toDB")
                .to("seda:toActiveMQ")

            .setHeader(Exchange.HTTP_RESPONSE_CODE, constant(200))
                .transform()
                .simple("Msg processed and generated as : ${body}")
            .endRest();

        //Defining subroutes...

        from("direct:toDB")
            .routeId("toDBId")
            .to("jpa:" + EmployeeSalary.class.getName());

        from("seda:toActiveMQ")//
            .routeId("toActiveMQId")
            .to(String.format("activemq:queue:%s%s", EMP_SAL_QUEUE, "?exchangePattern=InOnly"));

        //Defining both subroutes as asynchronous (i.e. "seda:toDB" and "seda:toActiveMQ") makes no sense.
        //Remember that wiretap messages are propagated through multiple threads. The order of these threads are
        // defined by the Camel context.
        //It is logical that the first operation must be synchronous (direct) so as to guarantee that the next
        //exchange will receive the complete information, including the id generated by the persistence layer. Due to
        //the nature of message queues, it is right to define its route as an asynchronous one.
    }
}
